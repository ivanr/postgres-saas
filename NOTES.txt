
- Evaluate: Reactive PostgreSQL Client
  https://vertx.io/docs/vertx-pg-client/java/


TODO
====

- Flyway

  - Model in one subproject, database code in second, schema in third

  - Embed the above in the application as needed

  - Standalone CLI to run Flyway w/picocli


- User expiration date.

- Service accounts are like user accounts, except that they're not attached to individuals.

- User accounts can be owned by a tenant, or they can exist separately. For example,
  service accounts are always owned by tenants.

- Personal service account or access token. Limited subaccount with separate authentication
  and configured permissions, but shared identity with the parent account.

  - Track purpose.

  - Should personal service accounts be tenant specific? Or specify which tenants to acces.

  - Inherit all permissions vs give only selected permissions.

  - Permissions have to be checked twice, first on the subaccount then on the
    main account. Either that, or trim subaccount permissions as permissions are
    changed on the main account.


- Row level security

  - Write a generic set of functions that can be reused and/or built on


- Job scheduling

  - created_on
  - last_success
  - last_attempt -- includes failures
  - next_scheduled -- this is when the job is supposed to be run
  - next_attempt -- this is the next attempt; if the job fails, next_scheduled stays the same
  - failed_attempts (since the last success)
  - priority -- integer from 0 to 10, default 5; maybe we want to support more elaborate strategies? For example have a fairness_key?
  - status -- healthy, failed
  - status_message
  - duration statistics: last duration, averages in the last M, N, P periods, total runs, total time

  + Scheduling metadata, for example: fixed rate, fixed delay, interval, cron schedule,
       how to reschedule after failures, etc

  + How do we know when to schedule a job in relation to other jobs? A job
    may have some resource requirements and compete with other jobs?

  + We also need to know what the job is. This will sometimes be understood
    from the context, but if we're building a generic job scheduling feature,
    we need some more information. For example:

    - type
    - input -- probably as JSON
    - input_payload -- for additional data, especially binary; JSON is inefficient for that
    - input_payload_ct -- (ct => content type)

  + We probably want to support multiple queues, but those should probably be implemented
    as separate tables using Postgres inheritance.

  + Use partitioning to minimise bloat; can partman should be able to be configured
    to drop partitions only if they're empty?

  + If not using partitioning, bloat can be fixed by copying the data into a temporary
    table, running truncate, then copying the data back.

  + Do we want to keep a record of job attempts and invocations? How about job results?
    Probably in a separate table where we can have custom retention rules.

- Are queues jobs that are immediately due?

- Prior art:

  - https://temporal.io

  - https://github.com/tembo-io/pgmq

  - https://hatchet.run


Transactional Pagination
========================

HOLD cursors are interesting, but they are bound to the database connection that
created them. Defeats the point of keeping the results on the server.

We can replicate the functionality of the HOLD cursors perhaps? Advantage: the new
table can be queried as any other table.

- SELECT into a new table

- Is it possible to somehow get the first N results quickly (e.g., to display
  to the user) while we continue to process the entire result? Maybe possible
  via cursors: create a cursor, read the first page, then materialise the
  cursor into a new table?

- Use garbage collection to delete stale tables; absolute timeout. pg_cron? We can
  probably use the catalog to avoid having separate accounting. Inactivity timeout?

  https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ALL-TABLES-VIEW

- Option to explicitly delete the table to reclaim the space immediately?

- Use a different tablespace, put on a less durable filesystem?

- If using UNLOGGED we get better performance, but no replication

- Perhaps this solution can be abstracted so that there is a separate
  Postgres server that we query through when we want this sort of thing.
  I suppose we could improve the performance of this separate instance
  further because we don't need strong durability for these. See postgres_fdw.
